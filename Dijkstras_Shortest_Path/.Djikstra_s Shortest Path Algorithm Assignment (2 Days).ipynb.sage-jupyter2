{"backend_state":"running","kernel":"python3","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":82477056},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.5"}},"trust":true,"type":"settings"}
{"cell_type":"code","exec_count":0,"id":"4db256","input":"","pos":18,"type":"cell"}
{"cell_type":"code","exec_count":2,"id":"0e0a96","input":"def dijkstra(G,s):\n    '''\n    return dictionary of lengths of the shortest distance\n    to each node from s\n    length to s is 0\n    inputs: graph, starting point\n    outputs: shortest path to all points found\n    '''\n    dist = {s: 0}  # the node distances\n    E = {s}  # set of explored nodes\n    while len(E) < len(G):\n        shortest = float('inf')  # setting the default shortest distance as infinitely long\n        for node in E:\n            for v in G[node]:\n                if v[0] in E:\n                    continue\n                v_star = dist[node] + v[1]  # current distance should the route be chosen\n                if v_star < shortest:  # compares the current v_star to the shortest out of all previous paths, even from different paths\n                    shortest = v_star\n                    optimal_node = v[0]\n        dist[optimal_node] = shortest\n        E.add(optimal_node)  # adding to explored\n    return dist\n","pos":3,"type":"cell"}
{"cell_type":"code","exec_count":27,"id":"f5c2de","input":"# 3 files to test in dictionary with {FILENAME: max_node}\nfilenames = {'dijkstra_test_1000.txt':1000,'dijkstra_test_5000.txt':5000, 'dijkstra_test_50000.txt':50000}\n\n# find the following\n# 1. the distance from node 1 to the max_node of the graph\n# 2. the node that has the longest path from node 1\ndef find_max(G: dict):\n    '''\n    finds the max distance node and the distance\n    input: graph\n    output: max node, max node distance\n    '''\n    len_dict = dict()\n    for i in G:\n        len_dict.setdefault(G[i], []).append(i)\n    return sorted(len_dict.keys())[-1], len_dict[sorted(len_dict.keys())[-1]]\n\nfor file in filenames:  # decided to test around with some exec and eval\n    name = file.split('.')[0]\n    exec(f\"{name} = {dijkstra_heap(load_graph(file), '1')}\")  # setting up a corresponding variable to the dictionary\n    print('loading complete')\n    print('last node distance: ', end = '')\n    exec(f'print({name}[str({filenames[file]})])')  # gets the distance of the last node\n    exec(f'dist, node = find_max({name})')\n    print(f'the furthest node/s is/are: {node} with a distance of {dist}')  # gets the furthest node (or nodes if there are multiple) and the distance\n","output":{"0":{"name":"stdout","output_type":"stream","text":"loading complete\nlast node distance: 595\nthe furthest node/s is/are: ['680'] with a distance of 1605\n"},"1":{"name":"stdout","output_type":"stream","text":"loading complete\nlast node distance: 2937\nthe furthest node/s is/are: ['3823'] with a distance of 5625\n"},"2":{"name":"stdout","output_type":"stream","text":"loading complete\nlast node distance: 35258\nthe furthest node/s is/are: ['28936'] with a distance of 76140\n"}},"pos":16,"scrolled":true,"type":"cell"}
{"cell_type":"code","exec_count":3,"id":"28e36c","input":"# def dijkstra(G, s):\n#     dist = {s: 0}\n#     E = {s}","pos":4,"type":"cell"}
{"cell_type":"code","exec_count":4,"id":"227265","input":"### Day 1, Part 1: Simple Test Graph\n\ngraph = {\n        'A': [('C', 4), ('F',7)],\n        'B': [('E',9), ('H',3)],\n        'C': [('A',4), ('F',2), ('D', 3), ('G', 9)],\n        'D': [('C',3), ('G',7), ('E', 3)],\n        'E': [('D',3), ('G',2), ('H', 7), ('B', 9)],\n        'F': [('A',7), ('C', 2), ('G',8)],\n        'G': [('F',8), ('H',3), ('C', 9), ('D', 7), ('E', 2)],\n        'H': [('G',3), ('E',7), ('B', 3)]\n        }\n\n# this cell should return a dictionary of the shortest paths from 'A' to all other nodes:\n# {'A': 0, 'C': 4, 'F': 6, 'D': 7, 'E': 10, 'G': 12, 'H': 15, 'B': 18}\n\ndijkstra(graph,'A')\n\n\n","output":{"0":{"data":{"text/plain":"{'A': 0, 'C': 4, 'F': 6, 'D': 7, 'E': 10, 'G': 12, 'H': 15, 'B': 18}"},"exec_count":4,"output_type":"execute_result"}},"pos":6,"type":"cell"}
{"cell_type":"code","exec_count":5,"id":"438460","input":"# use your dijkstra function to find the distance to \n\ninput_files = ['dijkstra_input_16_32.txt', 'dijkstra_input_22_128.txt', 'dijkstra_input_26_256.txt']\noutput_files = ['dijkstra_output_16_32.txt', 'dijkstra_output_22_128.txt', 'dijkstra_output_26_256.txt']\n\ndef load_graph(filename):\n    '''\n    takes a in a filename and returns a graph matching dictionary format above\n    inputs: file name\n    outputs: the dictionary formatted from the file\n    '''\n    d = {}\n    with open(filename) as file:\n        for line in file:\n            line = line.split()\n            for node in line[1::]:\n                d.setdefault(line[0], []).append((node.split(',')[0], int(node.split(',')[1])))\n    return d\n\n\ndef load_result(filename):\n    '''\n    formats the results\n    inputs: file name\n    outputs: a list of results\n    '''\n    with open(filename) as file:\n        for line in file:\n            l = [int(l) for l in line.split(',')]\n    return l\n\n# input_files = ['dijkstra_test_1000.txt', 'dijkstra_test_5000.txt', 'dijkstra_test_50000.txt']\nfiles = []\nfor graph, result in zip(input_files, output_files):\n    exec(f\"{graph.split('.')[0]} = {load_graph(graph)}\")\n    exec(f\"{result.split('.')[0]} = {load_result(result)}\")\n    files.append((graph.split('.')[0], result.split('.')[0]))\n\nnodes = [7,37,59,82,99,115,133,165,188,197]\nfor file in files:\n    l = [dijkstra(eval(file[0]), '1')[str(i)] for i in nodes]\n    print(l, eval(file[1]), l == eval(file[1]))","output":{"0":{"name":"stdout","output_type":"stream","text":"[10166, 18051, 15617, 16074, 16134, 15292, 17621, 18248, 15367, 13089] [10166, 18051, 15617, 16074, 16134, 15292, 17621, 18248, 15367, 13089] True\n"},"1":{"name":"stdout","output_type":"stream","text":"[232502, 181515, 149506, 143014, 106325, 338747, 172980, 124364, 162768, 156250] [232502, 181515, 149506, 143014, 106325, 338747, 172980, 124364, 162768, 156250] True\n"},"2":{"name":"stdout","output_type":"stream","text":"[158222, 152868, 156530, 166588, 123967, 120559, 150140, 122675, 137266, 149323] [158222, 152868, 156530, 166588, 123967, 120559, 150140, 122675, 137266, 149323] True\n"}},"pos":8,"type":"cell"}
{"cell_type":"code","exec_count":6,"id":"aeca55","input":"# input file for assessment\ninput_file = 'dijkstra_assessment_28.txt'\n\n# report distance from node 1 to following nodes, in order [7,37,59,82,99,115,133,165,188,197]\nf = load_graph(input_file)\nl = [dijkstra(f, '1')[str(i)] for i in nodes]\nprint(l)\n\n","output":{"0":{"name":"stdout","output_type":"stream","text":"[561210, 512598, 559247, 660768, 485338, 534807, 364902, 307456, 511454, 453935]\n"}},"pos":10,"type":"cell"}
{"cell_type":"code","exec_count":7,"id":"391fb1","input":"graph = {\n        'A': [('C', 4), ('F',7)],\n        'B': [('E',9), ('H',3)],\n        'C': [('A',4), ('F',2), ('D', 3), ('G', 9)],\n        'D': [('C',3), ('G',7), ('E', 3)],\n        'E': [('D',3), ('G',2), ('H', 7), ('B', 9)],\n        'F': [('A',7), ('C', 2), ('G',8)],\n        'G': [('F',8), ('H',3), ('C', 9), ('D', 7), ('E', 2)],\n        'H': [('G',3), ('E',7), ('B', 3)]\n        }","pos":2,"type":"cell"}
{"cell_type":"code","exec_count":7,"id":"dc13a9","input":"from heapq import heapify, heappop, heappush\n\n\n# discussed with Peter N, realized that I could do this like a BFS\ndef dijkstra_heap(G, s):\n    '''\n    runnign the dijkstra path finding algorithm with a similar style to bfs using heaps\n    inputs: graph, starting node\n    outputs: the distance dictionary of every element found to point s\n    '''\n    # graph G, start node s\n    # uses HEAP to speed up min spanning edge\n    # return dictionary of distance to each other node\n    \n    crossing_edges = [(0, s)]  # after discussion with peter, I realized I had no need for the middle point, just need the distance and final point\n    heapify(crossing_edges)  # setting up heap\n    dist = {i:float('inf') for i in G}  # dictionary comprehension to default values to infinity\n    dist[s] = 0\n    E = {s}\n    \n    while crossing_edges:\n        v = heappop(crossing_edges)\n        for route in G[v[1]]:\n            v_star = v[0] + route[1]\n            if v_star < dist[route[0]]:  # if the current v_star route is better, replace the previous/default\n                heappush(crossing_edges, (v_star, route[0]))\n                dist[route[0]] = v_star\n                \n    return dist\n\n\nprint('ready')\ngraph = {\n        'A': [('C', 4), ('F',7)],\n        'B': [('E',9), ('H',3)],\n        'C': [('A',4), ('F',2), ('D', 3), ('G', 9)],\n        'D': [('C',3), ('G',7), ('E', 3)],\n        'E': [('D',3), ('G',2), ('H', 7), ('B', 9)],\n        'F': [('A',7), ('C', 2), ('G',8)],\n        'G': [('F',8), ('H',3), ('C', 9), ('D', 7), ('E', 2)],\n        'H': [('G',3), ('E',7), ('B', 3)]\n        }\n\n# this cell should return a dictionary of the shortest paths from 'A' to all other nodes:\n# {'A': 0, 'C': 4, 'F': 6, 'D': 7, 'E': 10, 'G': 12, 'H': 15, 'B': 18}\nprint(dijkstra(graph,'A'))\nprint(dijkstra_heap(graph,'A'))\n","output":{"0":{"name":"stdout","output_type":"stream","text":"ready\n{'A': 0, 'C': 4, 'F': 6, 'D': 7, 'E': 10, 'G': 12, 'H': 15, 'B': 18}\n{'A': 0, 'B': 18, 'C': 4, 'D': 7, 'E': 10, 'F': 6, 'G': 12, 'H': 15}\n"}},"pos":12,"scrolled":true,"type":"cell"}
{"cell_type":"code","exec_count":8,"id":"1369a2","input":"### Tests go here for dijkstra_heap\nfor file in files:\n    l = [dijkstra(eval(file[0]), '1')[str(i)] for i in nodes]\n    print(l, eval(file[1]), l == eval(file[1]))\nfor file in files:\n    l = [dijkstra_heap(eval(file[0]), '1')[str(i)] for i in nodes]\n    print(l, eval(file[1]), l == eval(file[1]))","output":{"0":{"name":"stdout","output_type":"stream","text":"[10166, 18051, 15617, 16074, 16134, 15292, 17621, 18248, 15367, 13089] [10166, 18051, 15617, 16074, 16134, 15292, 17621, 18248, 15367, 13089] True\n"},"1":{"name":"stdout","output_type":"stream","text":"[232502, 181515, 149506, 143014, 106325, 338747, 172980, 124364, 162768, 156250] [232502, 181515, 149506, 143014, 106325, 338747, 172980, 124364, 162768, 156250] True\n"},"2":{"name":"stdout","output_type":"stream","text":"[158222, 152868, 156530, 166588, 123967, 120559, 150140, 122675, 137266, 149323] [158222, 152868, 156530, 166588, 123967, 120559, 150140, 122675, 137266, 149323] True\n[10166, 18051, 15617, 16074, 16134, 15292, 17621, 18248, 15367, 13089] [10166, 18051, 15617, 16074, 16134, 15292, 17621, 18248, 15367, 13089] True\n[232502, 181515, 149506, 143014, 106325, 338747, 172980, 124364, 162768, 156250] [232502, 181515, 149506, 143014, 106325, 338747, 172980, 124364, 162768, 156250] True\n"},"3":{"name":"stdout","output_type":"stream","text":"[158222, 152868, 156530, 166588, 123967, 120559, 150140, 122675, 137266, 149323] [158222, 152868, 156530, 166588, 123967, 120559, 150140, 122675, 137266, 149323] True\n"}},"pos":14,"type":"cell"}
{"cell_type":"markdown","id":"21cca9","input":"### Day 1, Part 1: Simple Test Graph","pos":5,"type":"cell"}
{"cell_type":"markdown","id":"3ad3f0","input":"### Day 1: Part 2: Tests of Larger Graphs\n\nIncluded in the CoCalc folder are 3 test files and the result you should get from that test file.\n\nThe files contain an adjacency list representation of an undirected weighted graph with 200 vertices labeled 1 to 200. Each row consists of the node tuples that are adjacent to that particular vertex along with the length of that edge. For example, if the 6th row has 6 as the first entry indicating that this row corresponds to the vertex labeled 6. The next entry of this row \"141,8200\" indicates that there is an edge between vertex 6 and vertex 141 that has length 8200. The rest of the pairs of this row indicate the other vertices adjacent to vertex 6 and the lengths of the corresponding edges.\n\nYour task is to run Dijkstra's shortest-path algorithm on this graph, using 1 (the first vertex) as the source vertex, and to compute the shortest-path distances between 1 and every other vertex of the graph.\n\nYou should report the shortest-path distances to the following ten vertices, in order: [7,37,59,82,99,115,133,165,188,197]\n\nThe correct results are also provided for you in the corresponding output files so you can check your work.\n\n","pos":7,"type":"cell"}
{"cell_type":"markdown","id":"55d6ac","input":"### Day 2, Part 2: Testing Dijkstra_heap\n\nReturn to Day 1, Part 2 and run your `dijkstra_heap` function with those test cases.  You should get the correct answers here before you move on to Part3","pos":13,"type":"cell"}
{"cell_type":"markdown","id":"6315c3","input":"### Djikstra's Shortest Path Algorithm\n\nThis is one of the classics and greatest hits of Computer Science Algorithms.  Given a weighted graph (directed or undirected) with non-negative edge lengths, what is the shortest path between two points.  For example, what is the shortest distance between Nodes A and B in the following graph, and what is the path?  \n\n![Weighted Graph attribution: https://stackoverflow.com/questions/33574048/finding-optimal-starting-point-in-weighted-graph](weighted_graph.png)\n\n```python\n# this is a representation of the graph above \n# using an adjacency list dictionary with \n# tuples indicating the weight of each edge\ngraph = {\n        'A': [('C', 4), ('F',7)],\n        'B': [('E',9), ('H',3)],\n        'C': [('A',4), ('F',2), ('D', 3), ('G', 9)],\n        'D': [('C',3), ('G',7), ('E', 3)],\n        'E': [('D',3), ('G',2), ('H', 7), ('B', 9)],\n        'F': [('A',7), ('C', 2), ('G',8)],\n        'G': [('F',8), ('H',3), ('C', 9), ('D', 7), ('E', 2)],\n        'H': [('G',3), ('E',7), ('B', 3)]\n        }\n```\n\nYou will write a `dijkstra` function that takes in a weighted connected graph, `G` and a node `s` in G and returns a dictionary with the distance from `s` to every other node in the graph.\n\nFor example if I ran the following for the above graph:\n```python\ndijkstra(graph, 'A')\n```\nit should return\n```python\n{'A': 0, 'C': 4, 'F': 6, 'D': 7, 'E': 10, 'G': 12, 'H': 15, 'B': 18}\n```\n\nAs discussed in class lecture, Dijkstra always proceeds by growing the the set of explored nodes by adding the shortest node that connects the Set of Explored Nodes to the Set of Unexplored Nodes.  For this implementation, you'll return a dictionary of the distance from `s` to every other node.  The distance from `s` to `s` is 0.\n\nOptionally, your function could also keep track of the PATH followed to get to each node in the shortest way possible so you don't just know the distance, but also the path required to get there in that distance.  For some applications of Dijkstras (like mapping software, for instance) it would be important to know both the distance AND the path you need to follow.\n\nIf you missed class lecture on Dijkstra, I will post that in Google Classroom, and/or you can watch the [Tim Roughgarden Video Introduction to Dijkstra's Algorithm](https://youtu.be/jRlNVmRjdRk) instead.\n\nIn this video, Roughgarden works out [some example scenarios of Dijkstra's](https://youtu.be/ahYhIzLklYo).","pos":0,"type":"cell"}
{"cell_type":"markdown","id":"6a6496","input":"### Day 2, Part 3: Document Your Work with a Video Explainer\n\nPost a video explanation of one or both of your Dijkstras Algorithm funtion on the [ALGORITHMS DOC](https://docs.google.com/spreadsheets/d/1QgLD9CET85d9O7AMwoSCk7IIS5JaTNzUc2upwfNlVxM/edit?usp=sharing)","pos":17,"type":"cell"}
{"cell_type":"markdown","id":"a1921c","input":"### Day 1, Part 3: Assessment_Sample\n\nCreate a graph of the file labeled \"dijkstra_assessment.txt\" and, as above, report the distances from nodes 1 to each of the following nodes, in order: [7,37,59,82,99,115,133,165,188,197]","pos":9,"type":"cell"}
{"cell_type":"markdown","id":"bdcddc","input":"### Day 2, Part 3: Testing Dijkstra_heap on LARGER graphs\n\nIf you've implemented `dijkstra_heap` correctly, it should enable the searching of much larger graphs than `dijkstra` without the HEAP.  In this part, you'll test your HEAP version on graphs of 1000, 5000 and 50000 nodes.\n\nAll of these should run in close to or under a second.\n\nFor each test graph, find 2 things:\n\n    1. the distance from node 1 to the last node of the graph\n    2. the node that has the longest path from node 1\n    \n    \n","pos":15,"type":"cell"}
{"cell_type":"markdown","id":"c9eaff","input":"### Day 2, part 1: Dijkstras with using a HEAP\n\nThis is a slightly more challenging implementation of Dijkstra's Algorithms, but it moves the algoirthms from **$ O(mn) $** to **$O(n\\log(m))$** which enables very fast searching of quite large graphs.\n\nFor this implementation, you'll use the the heapq library instead of writing your own heap data structure\n\n```python\nfrom heapq import heapify, heappop, heappush\n\n# example useage\nheapify(some_list) # in-place heapifies some_list\nheappop(some_list) # extracts min element from some_list and restores heap structure\nheappush(some_list, element) # adds element to some_list and restores heap structure\n\n# recall that you can add a tuple to a heap and it will use the\n# first element of the tuple as the value for sorting purposes\n```\n\nAs we discuss in class lecture, since Dijkstra's algorithms requires repeated minimum calculations to determine the best node to add to the Explored nodes.  This is the perfect opportunity to use a HEAP data structure, which can do take care of these minimum calculations in $\\log(n)$ time.\n\nIn this section you will write a `dijkstra_heap` function that implements Dijkstra's Shortest Path Algorithm by making use of a HEAP.  This will enable you to find paths on much larger graphs.\n\nAs above, this graph will also return a dictionary with the distances from node `s` to every other node.\n\nThis approach will take some extra thinking about what should go into the heap so that removing the minimum element from the heap will reveal the best candidate for extending the Explored set of nodes.\n\n**HINT 1**: you'll want to store a tuple in the HEAP with the v* distance as the first element and the nodes of the edge as the second and third elements.\n\n**HINT 2**: the min element in the HEAP will not always proper edge, because it's possible that both end points are already explored.  In this case, you should just pop that edge off the Heap and continue to next candidate.","pos":11,"type":"cell"}
{"cell_type":"markdown","id":"dbd186","input":"### Day 1, Part 1: Writing basic version of Dijkstra's Shortest Path Algorithm","pos":1,"type":"cell"}
{"id":0,"time":1606898671812,"type":"user"}
{"last_load":1606905386720,"type":"file"}