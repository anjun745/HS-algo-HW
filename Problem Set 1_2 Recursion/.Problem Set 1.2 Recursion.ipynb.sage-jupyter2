{"backend_state":"init","kernel":"python3","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"colab":{"name":"recursion2_euclid.ipynb","provenance":[]},"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.2"},"toc":{"base_numbering":1,"nav_menu":{},"number_sections":false,"sideBar":true,"skip_h1_title":false,"title_cell":"Table of Contents","title_sidebar":"Contents","toc_cell":false,"toc_position":{},"toc_section_display":true,"toc_window_display":false}},"trust":true,"type":"settings"}
{"cell_type":"code","exec_count":0,"id":"cf457c","input":"","pos":27,"type":"cell"}
{"cell_type":"code","exec_count":1,"id":"87fa95","input":"# EXAMPLE 1: \n\ndef overflow(x:int):\n    '''\n    This function takes in an integer and calls itself again until the input is 21\n    '''\n    \n    # this is the \"base case\" the case that will cause the function to end or \"return\"\n    if x == 21:\n        return\n    print(x)\n    \n    # this is the recursive call\n    # notice, on this example, I don't \"return\" the recursive call, I just make the call\n    # return overflow(x+1) would have the same result, though\n    overflow(x+1)\n    \noverflow(1)\n","output":{"0":{"name":"stdout","output_type":"stream","text":"1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n"}},"pos":1,"slide":"slide","type":"cell"}
{"cell_type":"code","exec_count":11,"id":"176238","input":"# fib\n\n\ndef fib(nth, initial=0):\n    '''\n    finds the nth fibonacci code\n    inputs: the position of the number to find, init should not take an input from the user\n    output: the nth fibonacci's number\n    '''\n    # base case\n    if nth <= 1:\n        return 1\n    # recursion\n    # for the nth number, it is equal to (n-1)th + (n-2)th, and the initial is as the name suggests, the base of the addition\n    return fib(nth-1, fib(nth-2)) + initial\n\n\nfor i in range(1,16):\n    print(fib(i), end = ' ')","metadata":{"colab":{},"colab_type":"code","id":"TjZyz18h0Ppj","outputId":"fc179521-f65e-4292-e143-ee7181845ef3"},"output":{"0":{"name":"stdout","output_type":"stream","text":"1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 "}},"pos":15,"type":"cell"}
{"cell_type":"code","exec_count":14,"id":"3baf53","input":"def towers_of_hanoi(n, from_post=\"A\", to_post=\"C\", middle_post=\"B\"):\n    pass\n        \n    \n# tests\ntowers_of_hanoi(2)\n    ","metadata":{"colab":{"base_uri":"https://localhost:8080/","height":66},"colab_type":"code","executionInfo":{"elapsed":608,"status":"ok","timestamp":1596819016207,"user":{"displayName":"Matt Pigg","photoUrl":"https://lh3.googleusercontent.com/a-/AOh14GjIfK2VpFOSyzkbJiAdGrz-CLoZ2l0V-QZLYf_P6g=s64","userId":"10983113340829288324"},"user_tz":420},"id":"cBiS7yZ70Ppt","outputId":"8c2ce48a-0e33-4a33-ecc4-659bc493350e"},"pos":24,"type":"cell"}
{"cell_type":"code","exec_count":2,"id":"b25f59","input":"# EXAMPLE 2\n# LABEL the BASE CASE and Recursive Call with #comments\n\ndef count_down(x):\n    if x == 0:\n        print(\"Blast Off\")\n        return\n    print(x)\n    return count_down(x-1)\n\ncount_down(10)","output":{"0":{"name":"stdout","output_type":"stream","text":"10\n9\n8\n7\n6\n5\n4\n3\n2\n1\nBlast Off\n"}},"pos":2,"type":"cell"}
{"cell_type":"code","exec_count":23,"id":"ea7534","input":"print('s'[1:])","output":{"0":{"name":"stdout","output_type":"stream","text":"\n"}},"pos":6,"type":"cell"}
{"cell_type":"code","exec_count":25,"id":"73fb6d","input":"def pal(a):\n    '''\n    takes in a string, and sees if it is a palindrome\n    '''\n    # base case, once it reaches 1 or below however, it will have already been proven to be a palindrome\n    if len(a) <= 1:\n        return True\n    # instead of detecting on the way back from base case, detect on the way down to base case\n    if a[0] != a[-1]:\n        return False\n    # recursion\n    return pal(a[1:-1])\n\n\n# tests\npal('amanaplanacanalpanama')","output":{"0":{"data":{"text/plain":"True"},"exec_count":25,"output_type":"execute_result"}},"pos":21,"type":"cell"}
{"cell_type":"code","exec_count":26,"id":"a0229e","input":"# alt solution\n\n\ndef fib(nth):\n    '''\n    no recursion in recursion\n    this is not inception\n    '''\n    # base\n    if nth <= 1:\n        # returns nth instead of 1 because wouldn't want fib(2) to be 1 + 1, it should be 1 + 0, as the second n is 0\n        return nth\n    # recursion, but simpler, just fib(n-1) + fib(n-2)\n    return fib(nth-1) + fib(nth-2)\n\n\nfor i in range(1, 16):\n    print(fib(i), end=' ')","output":{"0":{"name":"stdout","output_type":"stream","text":"1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 "}},"pos":16,"type":"cell"}
{"cell_type":"code","exec_count":27,"id":"c81cbf","input":"# write a recursive function that counts down from a given integer to 0\n# input = integer to start counting from\n\ndef count_up(x:int):\n    \"\"\"\n    assuming the input x is less than 50\n    \"\"\"\n    # your code here\n    if x >= 50:\n        print(50)\n        return\n    print(x)\n    return count_up(x+1)\n\ncount_up(69)","output":{"0":{"name":"stdout","output_type":"stream","text":"50\n"}},"pos":4,"slide":"skip","type":"cell"}
{"cell_type":"code","exec_count":28,"id":"dbcce8","input":"def reverse_str(word:str):\n    if not word:\n        return ''\n    return reverse_str(word[1:]) + word[0]\n\n\nreverse_str(\"matthew\")","output":{"0":{"data":{"text/plain":"'wehttam'"},"exec_count":28,"output_type":"execute_result"}},"pos":7,"slide":"slide","type":"cell"}
{"cell_type":"code","exec_count":29,"id":"23eef1","input":"# just a similar way of doing it\n\ndef pal(a):\n    if len(a) > 2:\n        if a[0] != a[-1]:\n            return False\n    if len(a) <= 1:\n        return True\n    return pal(a[1:-1])\n\npal('racer')","output":{"0":{"data":{"text/plain":"False"},"exec_count":29,"output_type":"execute_result"}},"pos":22,"type":"cell"}
{"cell_type":"code","exec_count":32,"id":"01dc8a","input":"def str_len(my_string: str):\n    '''\n    it counts how long a string is\n    '''\n    # base case, returns 0 as a starting point when the string is empty\n    if not my_string:\n        return 0\n    # recursion, adds one each time, lol\n    return str_len(my_string[:-1]) + 1\n\n\n# tests\nstr_len('aaaaaaaaaaa')","output":{"0":{"data":{"text/plain":"11"},"exec_count":32,"output_type":"execute_result"}},"pos":18,"type":"cell"}
{"cell_type":"code","exec_count":45,"id":"725ad3","input":"# factorial\n\ndef fact(n):\n    if n == 1:\n        return n\n    return n*fact(n-1)\n\nfact(225)","output":{"0":{"data":{"text/plain":"12593608545945996091036028947807033464712366100830310947884859323613908580199395683862487531069487476500759701742192535344540854068853669052295055299098464766181717162302204661624767827958051743017494348399489978246897042654475510812669519495908783832931264982964624146608320873210374164407022003675327475326979217376341678305184952924264841312344768880440433971238502679256760320000000000000000000000000000000000000000000000000000000"},"exec_count":45,"output_type":"execute_result"}},"pos":13,"type":"cell"}
{"cell_type":"code","exec_count":47,"id":"1c6e25","input":"def euclid(a, b, c=1):\n    '''\n    a and b are the numbers for greatest common factor, do not put an input for c, that is just there for recursive count\n    the data returned is a tuple of 2, with the first element being the gfc, and second being the recursive count\n    '''\n    # base case\n    if not a%b:\n        return b, c\n    # recursive call\n    c += 1\n    return euclid(b, a%b, c)\neuclid(50, 25)","metadata":{"colab":{},"colab_type":"code","id":"z8CjVs270Ppd","outputId":"e829331c-8296-4144-a13e-d5a4df521211"},"output":{"0":{"data":{"text/plain":"(25, 1)"},"exec_count":47,"output_type":"execute_result"}},"pos":9,"type":"cell"}
{"cell_type":"code","exec_count":48,"id":"bb5525","input":"C = 1\ndef euclid(a, b):\n    '''\n    same as above but no c as a parameter, instead c is global\n    '''\n    global C\n    if not a%b:\n        return b\n    C += 1\n    return euclid(b, a%b)\neuclid(20, 45)\nprint(C)","output":{"0":{"name":"stdout","output_type":"stream","text":"3\n"}},"pos":11,"type":"cell"}
{"cell_type":"code","exec_count":8,"id":"5fa724","input":"# towers of hanoi\n\ndef towers_of_hanoi(n, from_post=\"A\", to_post=\"C\", middle_post=\"B\"):\n    '''\n    tower of hanoi solver\n    inputs: disk count, start post, end post, mid post\n    prints out: the moves\n    '''\n    # base case\n    if n == 1:\n        print(f'Moved disk {n} from {from_post} to {to_post}!')\n    # recursion\n    else:\n        # keeps calling itself, alternating between the posts so that odd count would move to end to start, and even count would move to middle\n        towers_of_hanoi(n-1, from_post = from_post, to_post = middle_post, middle_post = to_post)\n        print(f'Moved disk {n} from {from_post} to {to_post}')\n        towers_of_hanoi(n-1, from_post = middle_post, to_post = to_post, middle_post = middle_post)\n    \n# tests\ntowers_of_hanoi(5)\n    ","output":{"0":{"name":"stdout","output_type":"stream","text":"Moved disk 1 from A to C!\nMoved disk 2 from A to B\nMoved disk 1 from C to B!\nMoved disk 3 from A to C\nMoved disk 1 from B to B!\nMoved disk 2 from B to C\nMoved disk 1 from B to C!\nMoved disk 4 from A to B\nMoved disk 1 from C to B!\nMoved disk 2 from C to C\nMoved disk 1 from B to C!\nMoved disk 3 from C to B\nMoved disk 1 from C to C!\nMoved disk 2 from C to B\nMoved disk 1 from C to B!\nMoved disk 5 from A to C\nMoved disk 1 from B to B!\nMoved disk 2 from B to C\nMoved disk 1 from B to C!\nMoved disk 3 from B to B\nMoved disk 1 from C to C!\nMoved disk 2 from C to B\nMoved disk 1 from C to B!\nMoved disk 4 from B to C\nMoved disk 1 from B to C!\nMoved disk 2 from B to B\nMoved disk 1 from C to B!\nMoved disk 3 from B to C\nMoved disk 1 from B to B!\nMoved disk 2 from B to C\nMoved disk 1 from B to C!\n"}},"pos":25,"type":"cell"}
{"cell_type":"markdown","id":"063488","input":"### Exercise 5\nWrite a function that RETURNS the **n**th term of the fibonacci sequence.\n\nThe loop at the bottom should print the first 15 terms of the fibonacci sequence.\n\n**Note**: label your base cases and recursive calls in each function\n\n**Hint:**: Think carefully about your input parameters.  Think back to `euclid` example.","pos":14,"type":"cell"}
{"cell_type":"markdown","id":"104a0a","input":"# Problem Set 1.2: Recursion\n\n    \n\"To understand recursion,  you must first understand recursion.\"\n\nWhen a programming challenge can be broken into smaller and smaller problems, each of which can be solved with the same method, it may lend itself to RECURSION.  \n\nRecursion is a method of solving a problem by breaking it into increasingly smaller problems until the answer to the smallest problem can be solved easily.  Then building these results back together to get the solution to the larger problem.\n\nA function is RECURSIVE if it makes a call to itself inside the function.  Like this:\n```python\ndef count_down(x):\n    if x == 0:\n        print(\"Blast Off\")\n        return\n    print(x)\n    return count_down(x-1)\n    \n```\nIn the `count_down` example, if the input is 0, the function prints BLASTOFF and then ends, but if `x` is greater than 0, `x` is printed and then the function calls itself (the **RECURSIVE call**) with `x-1`.  This repeats until the **\"Base Case\"** is reached at `x == 0`\n\nWatch the 2 videos below and Read the Article:\n\n\n* [Recursion with 2 examples in 3 minutes](https://www.youtube.com/watch?v=YZcO_jRhvxs)\n* [The Importance of a Base Case](https://www.loom.com/share/1caa2d176a504ecb8c042e03a2f6c364)\n* [Read this Article on Recursion](https://www.freecodecamp.org/news/how-recursion-works-explained-with-flowcharts-and-a-video-de61f40cb7f9/) -- pay close attention to the \"Call Stack\" section\n* [Understanding the Call Stack](https://www.loom.com/share/b3199b6c05bd44a995bfb9baaea66a7e)\n\nToday's Assignment: \n\nExample 1: overflow\n\nExample 2: count_down\n\n**Exercise 1**: count_up\n\n**Exercise 2**: reverse_string\n\n**Exercise 3**: Euclid's method of finding GCF `euclid`\n\n**Excerise 4**: factorial\n\n**Exercise 5**: fibonacci sequence\n\n**Exercise 6**: str_len\n\n**Exercise 7**: write a recursive function to check if a string is a palindrome\n\n**Challenge Exercise 8**:\nPlay the [Towers of Hanoi](https://www.mathsisfun.com/games/towerofhanoi.html)\nChallenge: write a recursive function to solve the towers of hanoi.\n\n### Explain with Loom  (~5 - 15 minutes)\n\nAFTER you have completed the exercises, post ONE 3 minute or shorter Loom Video explaining ONE of your recursive functions (Euclid, Fibonacci or Towers of Hanoi), how it works and any specific parts you found most challenging to figure out.  Post your Loom video explanation to the [ALGORITHMS DOC](https://docs.google.com/spreadsheets/d/1QgLD9CET85d9O7AMwoSCk7IIS5JaTNzUc2upwfNlVxM/edit?usp=sharing)\n\nAfter you have posted your video, choose one other video that has not been commented on yet and watch that video.  After watching, use the Google Commenting feature to add comments to the video cell that you are commenting on.  You MAY watch more than one video to see how others did it after you have made your first comment.  If you watch another video, however, you must leave a comment with feedback so they know it has been watched.\n\nREMEMBER: it may take you more than one try to get a good video that's under 3 minutes!\n\n\n\nNOTE: Recursion is challenging to wrap your head around. It takes lots of practice and examples.  Please communicate in the #general channel with questions and help each other out.  If you just can't figure any of them out and you find help or a solution online, make sure your cite your source and ALSO rewrite with your own code and your own extensive commenting.  Plagiarism does not make you a better coder.\n\n\n","pos":0,"slide":"slide","type":"cell"}
{"cell_type":"markdown","id":"32621e","input":"alt euclid keeping count","pos":10,"type":"cell"}
{"cell_type":"markdown","id":"5876c0","input":"### Remember to Explain with Loom  (~5 - 15 minutes)\n\nAFTER you have completed the exercises, post ONE 3 minute or shorter Loom Video explaining ONE of your recursive functions (Euclid, Fibonacci or Towers of Hanoi), how it works and any specific parts you found most challenging to figure out.  Post your Loom video explanation to the [ALGORITHMS DOC](https://docs.google.com/spreadsheets/d/1QgLD9CET85d9O7AMwoSCk7IIS5JaTNzUc2upwfNlVxM/edit?usp=sharing)\n\nAfter you have posted your video, choose one other video that has not been commented on yet and watch that video.  After watching, use the Google Commenting feature to add comments to the video cell that you are commenting on.  You MAY watch more than one video to see how others did it after you have made your first comment.  If you watch another video, however, you must leave a comment with feedback so they know it has been watched.\n\nREMEMBER: it may take you more than one try to get a good video that's under 3 minutes!","pos":26,"type":"cell"}
{"cell_type":"markdown","id":"60666b","input":"### Exercise 4\nWrite a recursive function that returns the factorial of a given input.","pos":12,"type":"cell"}
{"cell_type":"markdown","id":"6f5715","input":"### Exercise 3\n\nEuclid discovered a clever method for finding the greatest common factor (GCF) of 2 integers.  \n\nGiven two integers A and B, divide A by B.  If the remainder is 0, then B is the GCF.  If it is not 0, then replace A with B, replace B with the remainder, R, and repeat the division. Continue the process until R = 0.  When R is 0, then B is your GCF.  Sounds pretty recursive, yes?\n\nCreate a recursive function `euclid` that returns the GCF of 2 integers.\n\n**Note:** Your comments in the code should identify the **BASE CASE** and the **RECURSIVE CALL**\n\n**Challenge**: Keep track of how many steps your process went through to find the GCF and return that information as well.\n","pos":8,"type":"cell"}
{"cell_type":"markdown","id":"949d6f","input":"### Exercise 7\n\nWrite a recursive function that returns True if the input string is a palindrome, False if it is not\n","pos":19,"type":"cell"}
{"cell_type":"markdown","id":"9bf176","input":"### Challenge: Exercise 8\n\n\nPlay the [Towers of Hanoi](https://www.mathsisfun.com/games/towerofhanoi.html)\n\nWrite a recursive function to solve the towers of hanoi.  Your function should take in 4 arguments:\n```python\nn = the number of disks in your tower\nstarting_post_name = \"A\"\nending_post_name = \"B\"\nmiddle_post_name = \"C\"\n```\nThe function should print the directions for solving the puzzle.  eg, for n=2:\n```python\nMove disk 1 from A to B\nMove disk 2 from A to C\nMove disk 1 from B to C\n```\n\n**Hint**: 1) Play the game a bunch until you understand the pattern 2) you may need to use multiple recursive calls\n","pos":23,"type":"cell"}
{"cell_type":"markdown","id":"9fb8d9","input":"### Exercise 2\n\nCreate a recursive function that prints a string in reverse order.  Stuck?  Did you watch the videos above?","pos":5,"type":"cell"}
{"cell_type":"markdown","id":"c2a8f3","input":"### Exercise 6\n\nWrite a Recursive Function that returns the length of an input string","pos":17,"type":"cell"}
{"cell_type":"markdown","id":"fb4687","input":"### Exercise 1\n\nWrite a recursive function that counts up from a given integer to 50.\n\nMake sure the base case does not allow for a stack overflow.","pos":3,"type":"cell"}
{"cell_type":"raw","id":"d05f51","input":"split in 2\ncompare first and last element, then move in","pos":20,"type":"cell"}
{"id":0,"time":1614108095906,"type":"user"}
{"last_load":1602879511673,"type":"file"}