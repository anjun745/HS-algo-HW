{"backend_state":"running","kernel":"python3","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":82399232},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.5"},"toc":{"base_numbering":1,"nav_menu":{},"number_sections":false,"sideBar":true,"skip_h1_title":false,"title_cell":"Table of Contents","title_sidebar":"Contents","toc_cell":false,"toc_position":{},"toc_section_display":true,"toc_window_display":false}},"trust":true,"type":"settings"}
{"cell_type":"code","exec_count":0,"id":"25951f","input":"","pos":3,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"eb1eef","input":"","pos":15,"type":"cell"}
{"cell_type":"code","exec_count":1,"id":"26f0ea","input":"# Function to load a text file into an adjecency list graph in the form of a dictionary\n\ndef load_graph(file = \"4_letter_graph.txt\"):\n    '''\n    Reads a file in and returns a graph in the form of an adjacency list dictionary\n    inputs: file name\n    outputs: the adjacency list dictionary\n\n    '''\n    letter_dict = {}\n    with open(file, 'r') as f:\n        for line in f:\n            # make line a list and split the list into 2\n            letter_dict[line.split()[0]] = line.split()[1::]\n    return letter_dict\n\n","pos":2,"type":"cell"}
{"cell_type":"code","exec_count":2,"id":"e2f701","input":"# Basic BFS function to search a graph and return a set of\n# the nodes that can be found from given starting node, s \nfrom collections import deque\n\ndef BFS(G, s):\n    '''\n    Breadth First Search of a linked list Graph\n    inputs: graph of words, starting index\n    outputs: the set of all explored\n    \n    '''\n    E = set([s])\n    # starts with s as the starting node\n    Q = deque([s])\n    while Q:\n        v = Q.popleft()\n        for w in G[v]:\n            if w not in E:\n                Q.append(w)\n                E.add(w)\n\n\n    return E # the set of all the found nodes\n\n\n\n\n# This is the Graph from the Video to use for testing\n# your function should return a list of all the nodes reachable from s\n# I also added f, g, and h which may not be reachabe from s\n\nG = {'s':['a','b'],\n    'a': ['s','b','c'],\n    'b':['s','c','d'],\n    'c':['a','b','d'],\n    'd':['b','c','e'],\n    'e':['c','d'],\n     'f':['g','h'],\n     'g':['f'],\n     'h':['f']\n    }\n\nBFS(G, 's')\n","output":{"0":{"data":{"text/plain":"{'a', 'b', 'c', 'd', 'e', 's'}"},"exec_count":2,"output_type":"execute_result"}},"pos":7,"type":"cell"}
{"cell_type":"code","exec_count":3,"id":"1f1b6d","input":"def BFS_with_distance(G, s):\n    '''\n    finds the distance between all discovered nodes from starting item\n    inputs: graph, start point\n    outputs: dictionary of all discovered nodes and distances\n    '''\n    dist = {s:0}\n    # starts with s as the starting node\n    E = set([s])  # using list so that it doesn't spilt the strings up\n    Q = deque([s])\n    while Q:\n        v = Q.popleft()\n        for w in G[v]:\n            if w not in E:\n                Q.append(w)\n                E.add(w)\n                dist[w] = dist[v] + 1\n    return dist\n\n\nBFS_with_distance(G, 's')","output":{"0":{"data":{"text/plain":"{'s': 0, 'a': 1, 'b': 1, 'c': 2, 'd': 2, 'e': 3}"},"exec_count":3,"output_type":"execute_result"}},"pos":9,"type":"cell"}
{"cell_type":"code","exec_count":6,"id":"80b34e","input":"def BFS_path(G, s1, s2):\n    '''\n    finds the optimal path from s1 to s2\n    inputs: graph, starting point, end point\n    returns: the path from s1 to s2\n    '''\n    by = {s1: s1}\n    dist = {s1:0}\n    E = set([s1])\n    # starts with s as the starting node\n    Q = deque([s1])\n    while Q:\n        v = Q.popleft()\n        for w in G[v]:\n            if w not in E:\n                # changing the q and explored\n                Q.append(w)\n                E.add(w)\n                # distance keeping track, don't need it, but I wanted to keep it in case future alterations need it\n                dist[w] = dist[v] + 1\n                # keeps count of what an element is discovered by\n                by[w] = v\n    # starting an empty path\n    path = deque([])  # using deque so I can append left, and not do return path[::-1]\n    if s2 in E:  # assuming that the item is found\n        path.append(s2)\n        appending = by[s2]\n        while s1 not in path:  # backtracks until the starting node is in\n            path.appendleft(appending)\n            appending = by[appending]\n    return list(path)\n\nBFS_path(G, 's', 'e')","output":{"0":{"data":{"text/plain":"['s', 'b', 'd', 'e']"},"exec_count":6,"output_type":"execute_result"}},"pos":11,"type":"cell"}
{"cell_type":"code","exec_count":7,"id":"85c8cc","input":"for length in range(4, 6):\n    exec(f\"letter_graph_{length} = load_graph('{length}_letter_graph.txt')\")","pos":13,"type":"cell"}
{"cell_type":"code","exec_count":8,"id":"1afaa3","input":"# Here are some 5 and 4 letter test cases to try to solve and the length of their shortest path solutions\n# including the start and end word in the path\n\n# you'll use your load_graph function from Day 1 for this\n\ntest_cases5 = [('HONAN', 'ICERS', 15),\n ('ACKEE', 'RIGOL', 16),\n ('GAITT', 'IDOLA', 17),\n ('APPEL', 'LUNET', 18),\n ('HERTZ', 'INPUT', 21),\n ('MUSCA', 'UNCOY', 22),\n ('GLAUM', 'UNAIS', 24),\n              (\"GLAUM\", \"yeet\", 0)]\n\ntest_cases4 = [('KLIK', 'OFAY', 9),\n ('DHAK', 'EDHS', 10),\n ('IDOL', 'JEDI', 12),\n ('IDOL', 'JIAO', 13),\n ('ASHY', 'ODIC', 14),\n ('EGAL', 'UNAU', 15)]\n\n\nfor test in test_cases5:\n    if len(BFS_path(letter_graph_5, test[0], test[1])) == test[2]:\n        print(True, test[0], test[1], BFS_path(letter_graph_5, test[0], test[1]))\n    else:\n        print(False)\n        \nfor test in test_cases4:\n    if len(BFS_path(letter_graph_4, test[0], test[1])) == test[2]:\n        print(True, test[0], test[1], BFS_path(letter_graph_4, test[0], test[1]))\n    else:\n        print(False)","output":{"0":{"name":"stdout","output_type":"stream","text":"True HONAN ICERS ['HONAN', 'HOGAN', 'HOGEN', 'HOSEN', 'HOSES', 'HOKES', 'HYKES', 'TYKES', 'TYEES', 'TYERS', 'EYERS', 'EGERS', 'AGERS', 'ACERS', 'ICERS']\nTrue ACKEE RIGOL ['ACKEE', 'ACKER', 'OCKER', 'OAKER', 'BAKER', 'BAKES', 'BASES', 'BASIS', 'BASIN', 'BASON', 'BISON', 'VISON', 'VISOR', 'VIGOR', 'RIGOR', 'RIGOL']\n"},"1":{"name":"stdout","output_type":"stream","text":"True GAITT IDOLA ['GAITT', 'GAITS', 'BAITS', 'BAILS', 'VAILS', 'VRILS', 'ARILS', 'AXILS', 'AXELS', 'AVELS', 'OVELS', 'OVALS', 'ODALS', 'ODYLS', 'IDYLS', 'IDOLS', 'IDOLA']\nTrue APPEL LUNET ['APPEL', 'APPAL', 'APPAY', 'APPLY', 'AMPLY', 'AMPLE', 'AMOLE', 'ANOLE', 'ANILE', 'ANILS', 'ARILS', 'ARIAS', 'ARRAS', 'AURAS', 'AURES', 'AUNES', 'LUNES', 'LUNET']\nTrue HERTZ INPUT ['HERTZ', 'NERTZ', 'NERTS', 'CERTS', 'CERES', 'CEDES', 'CEDER', 'CIDER', 'EIDER', 'ENDER', 'ENDEW', 'ENSEW', 'UNSEW', 'UNSET', 'ONSET', 'ONCET', 'ONCES', 'ONCUS', 'INCUS', 'INCUT', 'INPUT']\nTrue MUSCA UNCOY ['MUSCA', 'MUSHA', 'MUSHY', 'BUSHY', 'BUSKY', 'BUSKS', 'BISKS', 'BISES', 'BIDES', 'BIDER', 'EIDER', 'ENDER', 'ENDEW', 'ENSEW', 'UNSEW', 'UNSET', 'ONSET', 'ONCET', 'ONCES', 'UNCES', 'UNCOS', 'UNCOY']\nTrue GLAUM UNAIS ['GLAUM', 'GLAUR', 'GLAIR', 'FLAIR', 'FLAIL', 'FRAIL', 'BRAIL', 'BRAIN', 'BLAIN', 'SLAIN', 'SPAIN', 'SPAIT', 'SPLIT', 'UPLIT', 'UNLIT', 'UNLET', 'UNSET', 'ONSET', 'ONCET', 'ONCES', 'ONCUS', 'UNCUS', 'UNAUS', 'UNAIS']\nTrue GLAUM yeet []\n"},"2":{"name":"stdout","output_type":"stream","text":"True KLIK OFAY ['KLIK', 'KAIK', 'KAIS', 'SAIS', 'SKIS', 'SKAS', 'OKAS', 'OKAY', 'OFAY']\nTrue DHAK EDHS ['DHAK', 'DHAL', 'CHAL', 'CHAT', 'SHAT', 'STAT', 'ETAT', 'ETAS', 'ETHS', 'EDHS']\nTrue IDOL JEDI ['IDOL', 'IDYL', 'ODYL', 'ODAL', 'ODAS', 'ODDS', 'OUDS', 'CUDS', 'CADS', 'CADI', 'CEDI', 'JEDI']\nTrue IDOL JIAO ['IDOL', 'IDYL', 'ODYL', 'ODAL', 'ODAS', 'OBAS', 'ABAS', 'AIAS', 'AITS', 'CITS', 'CITO', 'CIAO', 'JIAO']\nTrue ASHY ODIC ['ASHY', 'ACHY', 'ACHE', 'ACME', 'ALME', 'ALAE', 'SLAE', 'SPAE', 'SPIE', 'SPIC', 'EPIC', 'ETIC', 'OTIC', 'ODIC']\nTrue EGAL UNAU ['EGAL', 'EGAD', 'ECAD', 'ECOD', 'ECOS', 'EPOS', 'APOS', 'APTS', 'ANTS', 'ANTE', 'ANCE', 'UNCE', 'UNCI', 'UNAI', 'UNAU']\n"}},"pos":14,"type":"cell"}
{"cell_type":"code","exec_count":8,"id":"b3d9db","input":"d = set('a')\nd","output":{"0":{"data":{"text/plain":"{'a'}"},"exec_count":8,"output_type":"execute_result"}},"pos":6,"type":"cell"}
{"cell_type":"markdown","id":"2e9bc9","input":"### Day 2, Part 3: Solution: Finding the Path from Start Node to End Node\n\nThis is the final step!  This time, you are going to write a version of BFS that finds the shortest path between two nodes s1 and s2.  The function will return a list starting from s1 and ending at s2.\n\nFor the sample graph provided, for instance:\n```python\nBFS_path(G, 's', 'e')\n```\nmight return `['s', 'b', 'd', 'e']` or another viable list of the same length.\n\nThis one will require you to use a similar technique to Part 2 where you kept track of the distance to every node.  This time, I would suggest using a dictionary to keep track of each word that has been explored and which node discovered it.  This dictionary could the be used to backtrack from the end node to the start node to reveal the shortest path.\n\nIf no path is possible, the function should return and empty list.\n\n","pos":10,"type":"cell"}
{"cell_type":"markdown","id":"6087f1","input":"### COPY your function from Day 1, Part 5 here to allow you to quickly load your text file into an Adjacency List dictionary \n","pos":1,"type":"cell"}
{"cell_type":"markdown","id":"7cb4b0","input":"# DAY 2\n### Defeating Word GOLF with Graph Search in $O(m+n)$ time\n\n\nReminder: Here are the rules of **Word Golf**.  You are given two words of equal length, and you must find a path between those two words by only changing a single letter at a time to create a path of **real words** from the first word to the second.\n\nFor example:  If you are given these two words: **CARS** and **DRAT**, you might find a path like this:\n\n    CARS -> CART -> DART -> DAFT -> DEFT -> DEBT -> DEET -> BEET -> BEAT -> BRAT -> DRAT","pos":0,"type":"cell"}
{"cell_type":"markdown","id":"8a59ea","input":"### Day 2, Part 1: Searching the Graph\n\nWere going to using a new datastructure called a Queue for this function.  A Queue works on a First In First Out (FIFO) policy.  We could implement this with a list by removing items from the front of the list, and appending them to the end, but a list requires O(n) time to remove from the front, and a Queue can do this in O(1) time while still appending in O(1) time as well.\n\nWe'll use the deque class from the collections library like this:\n\n```python\nfrom collections import deque\n```\nOnce you define a Queue, you'll use the `.append` and `.popleft` methods.  [See this page for more detail about using deque](https://www.geeksforgeeks.org/deque-in-python/)\n\nIn addition, we'll be using a data structure called a SET to keep track of explored nodes.  A set can be initialized like this:\n```python\nE = set() # initialized empty set of explored nodes\n# or\nE = {s} # initialized set of explored nodes with the start node\n```\n\nLook-ups like ```'s' in E``` with a Set can be done in O(1) time, so they are very efficient to use when you need to do frequent fast lookups.  To add to a Set, you use the .add method instead of .append as you would do with a list.\n\n\nFor this part, you just want to successfully search through all the nodes you can reach given a single starting point.  You will simply return a set of all the nodes that can be reached from that given starting point.\n\nTo do this, you'll implement Breadth First Search (BFS) as [descibed in this Tim Roughgarden video](https://youtu.be/73qCvXsYkfk)\n","pos":5,"type":"cell"}
{"cell_type":"markdown","id":"bcc728","input":"### Day 2, Part 4:  Putting it all together to solve Word Golf\n\nUse your functions from Day 1 to load the graph (4 letter, 5 letter, 6 letter, etc) and solve some Word Golf Puzzles.\n","pos":12,"type":"cell"}
{"cell_type":"markdown","id":"e8770c","input":"## Day 2:  Breadth First Search (DFS) to Defeat Word Golf\n\nToday you will write a function that uses the Breadth First Search algorithm for exploring the graph of Scrabble Words Created on Day 1:\n\n### We're going to do this in Three Parts\n\n### Part 1: Searching the Graph\n\n\n### Part 2: Finding how many hops or layers from start to end word\n\n\n### Part 3: Solution: Finding the Path from Start Node to End Node\n\n\n### Part 4:  Putting it all together to solve Word Golf\n\n\n### Optional Additional Exploration\n\n    1) Finding words with the longest path between them (and not shorter paths possible)\n    2) Finding words that can not be reached\n\n","pos":4,"type":"cell"}
{"cell_type":"markdown","id":"ee1e30","input":"### Day 2, Part 2: Finding how many hops or layers from start to end word\n\n[Watch this 7 minute video on Calculating Shortest Path](https://youtu.be/AhEZ4yjkVxA)\n\nNote: One difference I recommend in your implementation is to use a python dictionary data structure for calculating the layer that a node is in.  The starting node would be a distance of Zero.  Such as:\n\n```python\ndist = {s:0}\n```\n\nCopy your BFS code from above but now you return the distance dictionary showing the distance from s to every point reachable by s.  For instance, it should contain the these key_value pairs:\n\n```python\ndist = {s: 0,\n        a: 1, \n        b: 1,\n        c: 2}\n```","pos":8,"type":"cell"}
{"id":0,"time":1605505363980,"type":"user"}
{"last_load":1605505363867,"type":"file"}